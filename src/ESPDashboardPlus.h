/**
 * ESP32 Dashboard Library
 * A real-time, on-device dashboard for ESP32 devices
 * 
 * Features:
 * - WebSocket-based real-time communication
 * - Multiple card types: stat, chart, button, toggle, slider, etc.
 * - OTA firmware updates
 * - Color picker, dropdown, input cards
 * - Action buttons with confirmation
 * - URL redirect buttons
 * - Timezone detection
 * - Date picker
 * - Status/feedback cards
 * 
 * Usage:
 *   #include "ESPDashboardPlus.h"
 *   #include "dashboard_html.h"  // Generated by html_to_header.py
 *   
 *   ESPDashboardPlus dashboard;
 *   
 *   void setup() {
 *     dashboard.begin(&server);
 *     dashboard.addStatCard("temp", "Temperature", "23.5", "Â°C");
 *     dashboard.addButtonCard("led", "LED Control", "Toggle LED", [](){ toggleLED(); });
 *   }
 *   
 *   void loop() {
 *     dashboard.loop();
 *     dashboard.updateStatCard("temp", String(readTemperature(), 1));
 *   }
 */

 #ifndef ESP_DASHBOARD_PLUS_H
 #define ESP_DASHBOARD_PLUS_H
 
 #include <Arduino.h>
 #include <ArduinoJson.h>
 #include <ESPAsyncWebServer.h>
 #if defined(ARDUINO_ARCH_ESP32)
 #include <Update.h>
 #endif
 #include <functional>
 #include <map>
 #include <vector>
 
 // Forward declarations
 class ESPDashboardPlus;
 class DashboardCard;
 
 // Callback types
 typedef std::function<void()> ButtonCallback;
 typedef std::function<void(const String&)> InputCallback;
 typedef std::function<void(bool)> ToggleCallback;
 typedef std::function<void(int)> SliderCallback;
 typedef std::function<void(const String&)> ColorCallback;
 typedef std::function<void(const String&)> DropdownCallback;
 typedef std::function<void(const String&, int, const String&)> TimezoneCallback;
 typedef std::function<void(const String&)> DateCallback;
 
 // Card types
 enum class CardType {
     STAT,
     CHART,
     BUTTON,
     ACTION,
     DATA_INPUT,
     COLOR,
     DROPDOWN,
     OTA,
     GAUGE,
     TOGGLE,
     SLIDER,
     LINK,
     TIMEZONE,
     DATE,
     STATUS,
     CONSOLE
 };
 
 // Log levels for console
 enum class LogLevel {
     DEBUG,
     INFO,
     WARNING,
     ERROR
 };
 
 // Log entry structure
 struct LogEntry {
     String timestamp;
     LogLevel level;
     String message;
 };
 
 // Card variant/color
 enum class CardVariant {
     PRIMARY,
     SUCCESS,
     WARNING,
     DANGER,
     INFO,
     SECONDARY
 };
 
 // Chart types
 enum class ChartType {
     LINE,
     AREA,
     BAR,
     SCATTER,
     STEP
 };
 
 // Status icons
 enum class StatusIcon {
     CHECK,
     ERROR,
     WARNING,
     INFO,
     WIFI,
     POWER,
     SYNC,
     CLOUD,
     LOCK,
     UNLOCK
 };
 
 // Dropdown option
 struct DropdownOption {
     String value;
     String label;
 };
 
 /**
  * Dashboard Card Base Class
  */
 class DashboardCard {
 public:
     String id;
     CardType type;
     String title;
     CardVariant variant;
     
     DashboardCard(const String& id, CardType type, const String& title)
         : id(id), type(type), title(title), variant(CardVariant::PRIMARY) {}
     
     virtual ~DashboardCard() {}
     
     virtual void toJson(JsonObject& card) = 0;
     virtual void handleAction(const String& action, JsonObject& data) {}
     
     void setVariant(CardVariant v) { variant = v; }
     
     // Public access for update helpers
     String getVariantString() { return variantToString(variant); }
     String getIconString(StatusIcon i) { return iconToString(i); }
     
 protected:
     String variantToString(CardVariant v) {
         switch (v) {
             case CardVariant::SUCCESS: return "success";
             case CardVariant::WARNING: return "warning";
             case CardVariant::DANGER: return "danger";
             case CardVariant::INFO: return "info";
             case CardVariant::SECONDARY: return "secondary";
             default: return "primary";
         }
     }
     
     String typeToString(CardType t) {
         switch (t) {
             case CardType::STAT: return "stat";
             case CardType::CHART: return "chart";
             case CardType::BUTTON: return "button";
             case CardType::ACTION: return "action";
             case CardType::DATA_INPUT: return "input";
             case CardType::COLOR: return "color";
             case CardType::DROPDOWN: return "dropdown";
             case CardType::OTA: return "ota";
             case CardType::GAUGE: return "gauge";
             case CardType::TOGGLE: return "toggle";
             case CardType::SLIDER: return "slider";
             case CardType::LINK: return "link";
             case CardType::TIMEZONE: return "timezone";
             case CardType::DATE: return "date";
             case CardType::STATUS: return "status";
             case CardType::CONSOLE: return "console";
             default: return "stat";
         }
     }
     
     String logLevelToString(LogLevel level) {
         switch (level) {
             case LogLevel::DEBUG: return "debug";
             case LogLevel::INFO: return "info";
             case LogLevel::WARNING: return "warning";
             case LogLevel::ERROR: return "error";
             default: return "info";
         }
     }
     
     String chartTypeToString(ChartType t) {
         switch (t) {
             case ChartType::AREA: return "area";
             case ChartType::BAR: return "bar";
             case ChartType::SCATTER: return "scatter";
             case ChartType::STEP: return "step";
             default: return "line";
         }
     }
     
     String iconToString(StatusIcon i) {
         switch (i) {
             case StatusIcon::CHECK: return "check";
             case StatusIcon::ERROR: return "error";
             case StatusIcon::WARNING: return "warning";
             case StatusIcon::INFO: return "info";
             case StatusIcon::WIFI: return "wifi";
             case StatusIcon::POWER: return "power";
             case StatusIcon::SYNC: return "sync";
             case StatusIcon::CLOUD: return "cloud";
             case StatusIcon::LOCK: return "lock";
             case StatusIcon::UNLOCK: return "unlock";
             default: return "info";
         }
     }
 };
 
 /**
  * Stat Card - Display a value with optional trend
  */
 class StatCard : public DashboardCard {
 public:
     String value;
     String unit;
     String trend; // "up", "down", or ""
     String trendValue;
     
     StatCard(const String& id, const String& title, const String& value = "", const String& unit = "")
         : DashboardCard(id, CardType::STAT, title), value(value), unit(unit) {}
     
     void toJson(JsonObject& card) override {
         card["id"] = id;
         card["type"] = typeToString(type);
         JsonObject config = card.createNestedObject("config");
         config["title"] = title;
         config["value"] = value;
         config["unit"] = unit;
         config["color"] = variantToString(variant);
         if (trend.length() > 0) {
             config["trend"] = trend;
             config["trendValue"] = trendValue;
         }
     }
     
     void setValue(const String& val) { value = val; }
     void setTrend(const String& t, const String& val) { trend = t; trendValue = val; }
 };
 
 /**
  * Status Card - Display icon + status message
  */
 class StatusCard : public DashboardCard {
 public:
     StatusIcon icon;
     String label;
     String message;
     
     StatusCard(const String& id, const String& title, StatusIcon icon = StatusIcon::INFO)
         : DashboardCard(id, CardType::STATUS, title), icon(icon) {}
     
     void toJson(JsonObject& card) override {
         card["id"] = id;
         card["type"] = typeToString(type);
         JsonObject config = card.createNestedObject("config");
         config["title"] = title;
         config["icon"] = iconToString(icon);
         config["variant"] = variantToString(variant);
         config["label"] = label;
         config["message"] = message;
     }
     
     void setStatus(StatusIcon i, CardVariant v, const String& lbl, const String& msg) {
         icon = i;
         variant = v;
         label = lbl;
         message = msg;
     }
     
     void setLabel(const String& lbl) { label = lbl; }
     void setMessage(const String& msg) { message = msg; }
     void setIcon(StatusIcon i) { icon = i; }
 };
 
 /**
  * Chart Card - Display a line/area/bar/scatter/step chart
  */
 class ChartCard : public DashboardCard {
 public:
     std::vector<float> data;
     ChartType chartType;
     int maxDataPoints;
     
     ChartCard(const String& id, const String& title, ChartType type = ChartType::LINE, int maxPoints = 20)
         : DashboardCard(id, CardType::CHART, title), chartType(type), maxDataPoints(maxPoints) {}
     
     void toJson(JsonObject& card) override {
         card["id"] = id;
         card["type"] = typeToString(type);
         JsonObject config = card.createNestedObject("config");
         config["title"] = title;
         config["chartType"] = chartTypeToString(chartType);
         config["color"] = variantToString(variant);
         JsonArray dataArr = config.createNestedArray("data");
         for (float val : data) {
             dataArr.add(val);
         }
     }
     
     void addDataPoint(float val) {
         data.push_back(val);
         if (data.size() > maxDataPoints) {
             data.erase(data.begin());
         }
     }
     
     void setChartType(ChartType t) { chartType = t; }
     void clearData() { data.clear(); }
 };
 
 /**
  * Button Card - Simple clickable button
  */
 class ButtonCardImpl : public DashboardCard {
 public:
     String label;
     String icon;
     ButtonCallback callback;
     
     ButtonCardImpl(const String& id, const String& title, const String& label, ButtonCallback cb)
         : DashboardCard(id, CardType::BUTTON, title), label(label), callback(cb) {}
     
     void toJson(JsonObject& card) override {
         card["id"] = id;
         card["type"] = typeToString(type);
         JsonObject config = card.createNestedObject("config");
         config["title"] = title;
         config["label"] = label;
         config["variant"] = variantToString(variant);
         if (icon.length() > 0) config["icon"] = icon;
     }
     
     void handleAction(const String& action, JsonObject& data) override {
         if (action == "click" && callback) {
             callback();
         }
     }
     
     void setIcon(const String& i) { icon = i; }
 };
 
 /**
  * Link Button Card - Button that redirects to URL
  */
 class LinkCard : public DashboardCard {
 public:
     String label;
     String url;
     String target; // "_blank", "_self"
     String icon;
     
     LinkCard(const String& id, const String& title, const String& label, const String& url)
         : DashboardCard(id, CardType::LINK, title), label(label), url(url), target("_blank") {}
     
     void toJson(JsonObject& card) override {
         card["id"] = id;
         card["type"] = typeToString(type);
         JsonObject config = card.createNestedObject("config");
         config["title"] = title;
         config["label"] = label;
         config["url"] = url;
         config["target"] = target;
         config["variant"] = variantToString(variant);
         if (icon.length() > 0) config["icon"] = icon;
     }
     
     void setTarget(const String& t) { target = t; }
     void setIcon(const String& i) { icon = i; }
     void setUrl(const String& u) { url = u; }
 };
 
 /**
  * Timezone Card - Button to get browser timezone
  */
 class TimezoneCard : public DashboardCard {
 public:
     String value;
     String label;
     TimezoneCallback callback;
     
     TimezoneCard(const String& id, const String& title, const String& label = "Get Browser Timezone")
         : DashboardCard(id, CardType::TIMEZONE, title), label(label) {
         variant = CardVariant::INFO;
     }
     
     void toJson(JsonObject& card) override {
         card["id"] = id;
         card["type"] = typeToString(type);
         JsonObject config = card.createNestedObject("config");
         config["title"] = title;
         config["label"] = label;
         config["value"] = value;
         config["variant"] = variantToString(variant);
     }
     
     void handleAction(const String& action, JsonObject& data) override {
         if (action == "timezone" && callback) {
             String tz = data["timezone"].as<String>();
             int offset = data["offset"].as<int>();
             String offsetStr = data["offsetString"].as<String>();
             value = tz + " (" + offsetStr + ")";
             callback(tz, offset, offsetStr);
         }
     }
     
     void setCallback(TimezoneCallback cb) { callback = cb; }
 };
 
 /**
  * Date Card - Date/DateTime picker
  */
 class DateCard : public DashboardCard {
 public:
     String value;
     bool includeTime;
     String minDate;
     String maxDate;
     DateCallback callback;
     
     DateCard(const String& id, const String& title, bool includeTime = false)
         : DashboardCard(id, CardType::DATE, title), includeTime(includeTime) {}
     
     void toJson(JsonObject& card) override {
         card["id"] = id;
         card["type"] = typeToString(type);
         JsonObject config = card.createNestedObject("config");
         config["title"] = title;
         config["value"] = value;
         config["includeTime"] = includeTime;
         if (minDate.length() > 0) config["min"] = minDate;
         if (maxDate.length() > 0) config["max"] = maxDate;
     }
     
     void handleAction(const String& action, JsonObject& data) override {
         if (action == "change" && !data["value"].isNull()) {
             value = data["value"].as<String>();
             if (callback) callback(value);
         }
     }
     
     void setCallback(DateCallback cb) { callback = cb; }
     void setRange(const String& min, const String& max) { minDate = min; maxDate = max; }
     void setValue(const String& val) { value = val; }
 };
 
 /**
  * Action Button - Button with confirmation popup
  */
 class ActionButton : public DashboardCard {
 public:
     String label;
     String confirmTitle;
     String confirmMessage;
     String icon;
     ButtonCallback callback;
     
     ActionButton(const String& id, const String& title, const String& label, 
                  const String& confirmTitle, const String& confirmMsg, ButtonCallback cb)
         : DashboardCard(id, CardType::ACTION, title), label(label), 
           confirmTitle(confirmTitle), confirmMessage(confirmMsg), callback(cb) {
         variant = CardVariant::WARNING;
     }
     
     void toJson(JsonObject& card) override {
         card["id"] = id;
         card["type"] = typeToString(type);
         JsonObject config = card.createNestedObject("config");
         config["title"] = title;
         config["label"] = label;
         config["confirmTitle"] = confirmTitle;
         config["confirmMessage"] = confirmMessage;
         config["variant"] = variantToString(variant);
         if (icon.length() > 0) config["icon"] = icon;
     }
     
     void handleAction(const String& action, JsonObject& data) override {
         if (action == "confirm" && callback) {
             callback();
         }
     }
     
     void setIcon(const String& i) { icon = i; }
 };
 
 /**
  * Input Card - Text/number input field
  */
 class InputCard : public DashboardCard {
 public:
     String value;
     String placeholder;
     String inputType; // "text", "number", "password"
     String unit;
     float min, max, step;
     InputCallback onChange;
     InputCallback onSubmit;
     
     InputCard(const String& id, const String& title, const String& placeholder = "")
         : DashboardCard(id, CardType::DATA_INPUT, title), placeholder(placeholder), 
           inputType("text"), min(0), max(100), step(1) {}
     
     void toJson(JsonObject& card) override {
         card["id"] = id;
         card["type"] = typeToString(type);
         JsonObject config = card.createNestedObject("config");
         config["title"] = title;
         config["value"] = value;
         config["placeholder"] = placeholder;
         config["inputType"] = inputType;
         config["unit"] = unit;
         if (inputType == "number") {
             config["min"] = min;
             config["max"] = max;
             config["step"] = step;
         }
     }
     
     void handleAction(const String& action, JsonObject& data) override {
         if (!data["value"].isNull()) {
             value = data["value"].as<String>();
             if (action == "change" && onChange) {
                 onChange(value);
             } else if (action == "submit" && onSubmit) {
                 onSubmit(value);
             }
         }
     }
     
     void setNumberInput(float minVal, float maxVal, float stepVal, const String& unitStr = "") {
         inputType = "number";
         min = minVal;
         max = maxVal;
         step = stepVal;
         unit = unitStr;
     }
     
     void setValue(const String& val) { value = val; }
 };
 
 /**
  * Color Picker Card
  */
 class ColorPickerCard : public DashboardCard {
 public:
     String value;
     std::vector<String> presets;
     ColorCallback onChange;
     
     ColorPickerCard(const String& id, const String& title, const String& defaultColor = "#00D4AA")
         : DashboardCard(id, CardType::COLOR, title), value(defaultColor) {
         // Default presets
         presets = {"#00D4AA", "#22C55E", "#F59E0B", "#F97316", "#EF4444", 
                    "#EC4899", "#8B5CF6", "#3B82F6", "#06B6D4", "#FFFFFF"};
     }
     
     void toJson(JsonObject& card) override {
         card["id"] = id;
         card["type"] = typeToString(type);
         JsonObject config = card.createNestedObject("config");
         config["title"] = title;
         config["value"] = value;
         JsonArray presetsArr = config.createNestedArray("presets");
         for (const String& preset : presets) {
             presetsArr.add(preset);
         }
     }
     
     void handleAction(const String& action, JsonObject& data) override {
         if (action == "change" && !data["color"].isNull()) {
             value = data["color"].as<String>();
             if (onChange) {
                 onChange(value);
             }
         }
     }
     
     void setPresets(std::vector<String>& p) { presets = p; }
     void setValue(const String& val) { value = val; }
 };
 
 /**
  * Dropdown Card
  */
 class DropdownCardImpl : public DashboardCard {
 public:
     String value;
     String placeholder;
     std::vector<DropdownOption> options;
     DropdownCallback onChange;
     
     DropdownCardImpl(const String& id, const String& title, const String& placeholder = "Select...")
         : DashboardCard(id, CardType::DROPDOWN, title), placeholder(placeholder) {}
     
     void toJson(JsonObject& card) override {
         card["id"] = id;
         card["type"] = typeToString(type);
         JsonObject config = card.createNestedObject("config");
         config["title"] = title;
         config["value"] = value;
         config["placeholder"] = placeholder;
         JsonArray optionsArr = config.createNestedArray("options");
         for (const DropdownOption& opt : options) {
             JsonObject optObj = optionsArr.createNestedObject();
             optObj["value"] = opt.value;
             optObj["label"] = opt.label;
         }
     }
     
     void handleAction(const String& action, JsonObject& data) override {
         if (action == "change" && !data["value"].isNull()) {
             value = data["value"].as<String>();
             if (onChange) {
                 onChange(value);
             }
         }
     }
     
     void addOption(const String& val, const String& label) {
         options.push_back({val, label});
     }
     
     void setValue(const String& val) { value = val; }
 };
 
 /**
  * Toggle Card - On/Off switch
  */
 class ToggleCard : public DashboardCard {
 public:
     bool value;
     String label;
     ToggleCallback onChange;
     
     ToggleCard(const String& id, const String& title, const String& label = "", bool defaultValue = false)
         : DashboardCard(id, CardType::TOGGLE, title), label(label), value(defaultValue) {}
     
     void toJson(JsonObject& card) override {
         card["id"] = id;
         card["type"] = typeToString(type);
         JsonObject config = card.createNestedObject("config");
         config["title"] = title;
         config["label"] = label;
         config["value"] = value;
     }
     
     void handleAction(const String& action, JsonObject& data) override {
         if (action == "change" && !data["value"].isNull()) {
             value = data["value"].as<bool>();
             if (onChange) {
                 onChange(value);
             }
         }
     }
     
     void setValue(bool val) { value = val; }
 };
 
 /**
  * Slider Card - Range slider
  */
 class SliderCard : public DashboardCard {
 public:
     int value;
     int min, max, step;
     String unit;
     SliderCallback onChange;
     
     SliderCard(const String& id, const String& title, int min = 0, int max = 100, int step = 1, const String& unit = "")
         : DashboardCard(id, CardType::SLIDER, title), min(min), max(max), step(step), unit(unit), value(min) {}
     
     void toJson(JsonObject& card) override {
         card["id"] = id;
         card["type"] = typeToString(type);
         JsonObject config = card.createNestedObject("config");
         config["title"] = title;
         config["value"] = value;
         config["min"] = min;
         config["max"] = max;
         config["step"] = step;
         config["unit"] = unit;
     }
     
     void handleAction(const String& action, JsonObject& data) override {
         if (action == "change" && !data["value"].isNull()) {
             value = data["value"].as<int>();
             if (onChange) {
                 onChange(value);
             }
         }
     }
     
     void setValue(int val) { value = constrain(val, min, max); }
 };
 
 /**
  * Gauge Card - Circular gauge display
  */
 class GaugeCard : public DashboardCard {
 public:
     float value;
     float min, max;
     String unit;
     float warningThreshold;
     float dangerThreshold;
     
     GaugeCard(const String& id, const String& title, float min = 0, float max = 100, const String& unit = "%")
         : DashboardCard(id, CardType::GAUGE, title), min(min), max(max), unit(unit), 
           value(min), warningThreshold(70), dangerThreshold(90) {}
     
     void toJson(JsonObject& card) override {
         card["id"] = id;
         card["type"] = typeToString(type);
         JsonObject config = card.createNestedObject("config");
         config["title"] = title;
         config["value"] = value;
         config["min"] = min;
         config["max"] = max;
         config["unit"] = unit;
         JsonObject thresholds = config.createNestedObject("thresholds");
         thresholds["warning"] = warningThreshold;
         thresholds["danger"] = dangerThreshold;
     }
     
     void setValue(float val) { value = constrain(val, min, max); }
     void setThresholds(float warning, float danger) { warningThreshold = warning; dangerThreshold = danger; }
 };
 
 /**
  * OTA Upload Card
  */
 class OTACard : public DashboardCard {
 public:
     int maxSizeMB;
     std::function<void(size_t, size_t)> onProgress;
     std::function<void(bool)> onComplete;
     
     OTACard(const String& id, const String& title = "Firmware Update (OTA)", int maxSize = 4)
         : DashboardCard(id, CardType::OTA, title), maxSizeMB(maxSize) {}
     
     void toJson(JsonObject& card) override {
         card["id"] = id;
         card["type"] = typeToString(type);
         JsonObject config = card.createNestedObject("config");
         config["title"] = title;
         config["maxSize"] = maxSizeMB;
     }
 };
 
 /**
  * Console Log Card - Displays timestamped log entries
  */
 class ConsoleCard : public DashboardCard {
 public:
     std::vector<LogEntry> logs;
     int maxEntries;
     bool autoScroll;
     std::function<void()> onClear;
     std::function<void(const String&)> onCommand;
     
     ConsoleCard(const String& id, const String& title = "Console Log", int maxEntries = 100)
         : DashboardCard(id, CardType::CONSOLE, title), maxEntries(maxEntries), autoScroll(true) {}
     
     void toJson(JsonObject& card) override {
         card["id"] = id;
         card["type"] = typeToString(type);
         JsonObject config = card.createNestedObject("config");
         config["title"] = title;
         config["autoScroll"] = autoScroll;
         JsonArray logsArr = config.createNestedArray("logs");
         for (const LogEntry& entry : logs) {
             JsonObject logObj = logsArr.createNestedObject();
             logObj["timestamp"] = entry.timestamp;
             logObj["level"] = logLevelToString(entry.level);
             logObj["message"] = entry.message;
         }
     }
     
     void handleAction(const String& action, JsonObject& data) override {
         if (action == "clear") {
             logs.clear();
             if (onClear) onClear();
         } else if (action == "command" && !data["command"].isNull()) {
             String cmd = data["command"].as<String>();
             if (onCommand) onCommand(cmd);
         }
     }
     
     void addLog(LogLevel level, const String& message) {
         LogEntry entry;
         entry.timestamp = getTimestamp();
         entry.level = level;
         entry.message = message;
         
         logs.push_back(entry);
         
         // Trim old entries if exceeding max
         while (logs.size() > maxEntries) {
             logs.erase(logs.begin());
         }
     }
     
     void clear() { logs.clear(); }
     
     // Public accessor for log level string conversion
     String getLogLevelString(LogLevel level) { return logLevelToString(level); }
     
 private:
     String getTimestamp() {
         unsigned long ms = millis();
         unsigned long secs = ms / 1000;
         unsigned long mins = secs / 60;
         unsigned long hours = mins / 60;
         
         char buf[16];
         snprintf(buf, sizeof(buf), "%02lu:%02lu:%02lu.%03lu", 
                  hours % 24, mins % 60, secs % 60, ms % 1000);
         return String(buf);
     }
 };
 
/**
 * Main Dashboard Class
 */
class ESPDashboardPlus {
private:
    AsyncWebServer* _server;
    AsyncWebSocket* _ws;
    std::map<String, DashboardCard*> _cards;
    String _title;
    String _subtitle;
    
    // OTA state
    bool _otaInProgress;
    size_t _otaSize;
    size_t _otaReceived;
    
   // HTML data (for PROGMEM)
   const uint8_t* _htmlData;
   size_t _htmlSize;
   
   // Heartbeat tracking
   unsigned long _lastHeartbeat;
   
   // Tab configuration
   bool _enableOTA;
   bool _enableConsole;
   
   // Global command handler (for console tab)
   std::function<void(const String&)> _onCommand;
   
   // Firmware version info (for OTA tab)
   String _version;
   String _lastUpdate;
    
    // Robust WebSocket JSON handler: parses exactly len bytes from data buffer
    void handleWebSocketMessage(AsyncWebSocketClient* client, const uint8_t* data, size_t len) {
        if (len == 0 || data == nullptr) {
            // Ignore empty frames
            return;
        }
        
        StaticJsonDocument<4096> doc;
        // Explicitly cast to const char* to ensure correct ArduinoJson overload
        DeserializationError error = deserializeJson(doc, (const char*)data, len);
        
        if (error) {
            Serial.print("[Dashboard] JSON parse error: ");
            Serial.println(error.c_str());
            return;
        }
      
       String type = doc["type"].as<String>();
        
       if (type == "init") {
           sendCardsToClient(client);
       } else if (type == "action") {
           String cardId = doc["cardId"].as<String>();
           String action = doc["action"].as<String>();
           JsonObject dataObj = doc["data"].as<JsonObject>();
           
           if (_cards.find(cardId) != _cards.end()) {
               _cards[cardId]->handleAction(action, dataObj);
               
               // Handle OTA actions
#if defined(ARDUINO_ARCH_ESP32)
               if (action == "ota_start") {
                   _otaSize = dataObj["size"].as<size_t>();
                   _otaReceived = 0;
                   _otaInProgress = true;
                   
                   if (!Update.begin(_otaSize)) {
                       Serial.print("[Dashboard] OTA begin failed: ");
                       Update.printError(Serial);
                       _otaInProgress = false;
                   }
               } else if (action == "ota_chunk" && _otaInProgress) {
                   String b64Data = dataObj["data"].as<String>();
                   size_t decodedLen = base64_decode_length(b64Data);
                   uint8_t* decoded = new uint8_t[decodedLen];
                   base64_decode(b64Data, decoded);
                   
                   Update.write(decoded, decodedLen);
                   _otaReceived += decodedLen;
                   
                   delete[] decoded;
               } else if (action == "ota_end" && _otaInProgress) {
                   if (Update.end(true)) {
                       Serial.println("[Dashboard] OTA complete, restarting...");
                       delay(1000);
                       ESP.restart();
                   } else {
                       Serial.println("[Dashboard] OTA end failed");
                   }
                   _otaInProgress = false;
               }
#else
               if (action == "ota_start" || action == "ota_chunk" || action == "ota_end") {
                   Serial.println("[Dashboard] OTA not supported on this platform");
                   _otaInProgress = false;
               }
#endif
           }
       } else if (type == "command") {
            // Global command from console tab
            String command = doc["command"].as<String>();
            if (_onCommand) {
                _onCommand(command);
            }
       } else if (type == "ota_start" || type == "ota_chunk" || type == "ota_end") {
           // Handle OTA from the dedicated OTA tab (not card-based)
#if defined(ARDUINO_ARCH_ESP32)
           if (type == "ota_start") {
               _otaSize = doc["size"].as<size_t>();
               _otaReceived = 0;
               _otaInProgress = true;
               
               if (!Update.begin(_otaSize)) {
                   Serial.print("[Dashboard] OTA begin failed: ");
                   Update.printError(Serial);
                   _otaInProgress = false;
               }
           } else if (type == "ota_chunk" && _otaInProgress) {
               String b64Data = doc["data"].as<String>();
               size_t decodedLen = base64_decode_length(b64Data);
               uint8_t* decoded = new uint8_t[decodedLen];
               base64_decode(b64Data, decoded);
               
               Update.write(decoded, decodedLen);
               _otaReceived += decodedLen;
               
               delete[] decoded;
           } else if (type == "ota_end" && _otaInProgress) {
               if (Update.end(true)) {
                   Serial.println("[Dashboard] OTA complete, restarting...");
                   delay(1000);
                   ESP.restart();
               } else {
                   Serial.println("[Dashboard] OTA end failed");
               }
               _otaInProgress = false;
           }
#else
           Serial.println("[Dashboard] OTA not supported on this platform");
#endif
       }
   }
     
    void sendCardsToClient(AsyncWebSocketClient* client) {
        DynamicJsonDocument doc(8192);
        doc["type"] = "init";
        doc["title"] = _title;
        if (_subtitle.length() > 0) {
            doc["subtitle"] = _subtitle;
        }
        doc["enableOTA"] = _enableOTA;
        doc["enableConsole"] = _enableConsole;
        
        // Include version info for OTA tab
        if (_version.length() > 0) {
            doc["version"] = _version;
        }
        if (_lastUpdate.length() > 0) {
            doc["lastUpdate"] = _lastUpdate;
        }
        
        JsonArray cardsArray = doc.createNestedArray("cards");
        
        for (auto& pair : _cards) {
            JsonObject card = cardsArray.createNestedObject();
            pair.second->toJson(card);
        }
        
        String output;
        serializeJson(doc, output);
        client->text(output);
    }
     
     // Base64 helpers
     size_t base64_decode_length(const String& input) {
         size_t len = input.length();
         size_t padding = 0;
         if (len >= 2) {
             if (input[len - 1] == '=') padding++;
             if (input[len - 2] == '=') padding++;
         }
         return (len * 3 / 4) - padding;
     }
     
     void base64_decode(const String& input, uint8_t* output) {
         static const char* b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
         size_t j = 0;
         uint32_t buf = 0;
         int bits = 0;
         
         for (size_t i = 0; i < input.length(); i++) {
             char c = input[i];
             if (c == '=') break;
             
             const char* p = strchr(b64chars, c);
             if (!p) continue;
             
             buf = (buf << 6) | (p - b64chars);
             bits += 6;
             
             if (bits >= 8) {
                 bits -= 8;
                 output[j++] = (buf >> bits) & 0xFF;
            }
        }
    }
    
    void sendHeartbeat() {
        if (!_ws) return;
        
        // Send a minimal heartbeat message
        StaticJsonDocument<64> doc;
        doc["type"] = "heartbeat";
        doc["timestamp"] = millis();
        
        String output;
        serializeJson(doc, output);
        _ws->textAll(output);
    }

public:
    ESPDashboardPlus(const String& title = "ESP32 Dashboard") 
        : _title(title), _server(nullptr), _ws(nullptr), 
          _otaInProgress(false), _otaSize(0), _otaReceived(0),
          _htmlData(nullptr), _htmlSize(0), _lastHeartbeat(0),
          _enableOTA(true), _enableConsole(true) {}
     
     ~ESPDashboardPlus() {
         for (auto& pair : _cards) {
             delete pair.second;
         }
         _cards.clear();
     }
 
// Backwards compatibility alias
using ESPDashboard = ESPDashboardPlus;
    
    /**
     * Initialize dashboard with PROGMEM HTML data
     * Use html_to_header.py to generate the header file
     * 
     * @param server The AsyncWebServer instance
     * @param htmlData The PROGMEM HTML data
     * @param htmlSize The size of the HTML data
     * @param enableOTA Enable the OTA firmware update tab
     * @param enableConsole Enable the console log tab
     * @param wsPath The WebSocket path (default: "/ws")
     */
    void begin(AsyncWebServer* server, const uint8_t* htmlData, size_t htmlSize, 
               bool enableOTA = true, bool enableConsole = true, const String& wsPath = "/ws") {
        _server = server;
        _ws = new AsyncWebSocket(wsPath);
        _htmlData = htmlData;
        _htmlSize = htmlSize;
        _enableOTA = enableOTA;
        _enableConsole = enableConsole;
        
        // WebSocket event handler
        _ws->onEvent([this](AsyncWebSocket* server, AsyncWebSocketClient* client, 
                           AwsEventType type, void* arg, uint8_t* data, size_t len) {
            if (type == WS_EVT_CONNECT) {
                Serial.printf("[Dashboard] Client #%u connected\n", client->id());
                sendCardsToClient(client);
            } else if (type == WS_EVT_DISCONNECT) {
                Serial.printf("[Dashboard] Client #%u disconnected\n", client->id());
            } else if (type == WS_EVT_DATA) {
                AwsFrameInfo* info = (AwsFrameInfo*)arg;
                // Only handle complete text frames to avoid partial JSON
                if (info->opcode == WS_TEXT && info->final && info->index == 0 && info->len == len) {
                    handleWebSocketMessage(client, data, len);
                } else if (info->opcode == WS_TEXT && info->final && (info->index + len) == info->len) {
                    // In case AsyncWebSocket ever fragments frames, we should ideally
                    // reassemble them; for now, ignore partial frames to avoid parse errors.
                    // (Can be extended to accumulate into a buffer if needed.)
                    handleWebSocketMessage(client, data, len);
                }
            }
        });
        
        _server->addHandler(_ws);
        
        // Serve compressed dashboard HTML from PROGMEM
        _server->on("/", HTTP_GET, [this](AsyncWebServerRequest* request) {
            AsyncWebServerResponse* response = request->beginResponse_P(
                200, "text/html", _htmlData, _htmlSize);
            response->addHeader("Content-Encoding", "gzip");
            response->addHeader("Cache-Control", "max-age=86400");
            request->send(response);
        });
        
        Serial.println("[Dashboard] Initialized with PROGMEM HTML");
        Serial.printf("[Dashboard] OTA: %s, Console: %s\n", 
                      enableOTA ? "enabled" : "disabled", 
                      enableConsole ? "enabled" : "disabled");
    }
     
    void loop() {
        if (_ws) {
            _ws->cleanupClients();
            
            // Send heartbeat every 2.5 seconds
            unsigned long now = millis();
            if (now - _lastHeartbeat >= 2500) {
                sendHeartbeat();
                _lastHeartbeat = now;
            }
        }
    }
     
    void setTitle(const String& title) { _title = title; }
    void setSubtitle(const String& subtitle) { _subtitle = subtitle; }
    void setTitle(const String& title, const String& subtitle) { _title = title; _subtitle = subtitle; }
    
    /**
     * Set version info for OTA tab display
     */
    void setVersionInfo(const String& version, const String& lastUpdate = "") {
        _version = version;
        _lastUpdate = lastUpdate;
    }
    
    /**
     * Set the global command handler for console tab input
     * This is called when a user sends a command from the Console tab
     */
    void onCommand(std::function<void(const String&)> handler) {
        _onCommand = handler;
    }
    
    /**
     * Check if OTA is enabled
     */
    bool isOTAEnabled() const { return _enableOTA; }
    
    /**
     * Check if Console is enabled
     */
    bool isConsoleEnabled() const { return _enableConsole; }
     
     // Broadcast update to all clients
     void broadcastUpdate(const String& cardId, JsonObject& data) {
         if (!_ws) return;
         
         StaticJsonDocument<512> doc;
         doc["type"] = "update";
         doc["cardId"] = cardId;
         doc["data"] = data;
         
         String output;
         serializeJson(doc, output);
         _ws->textAll(output);
     }
     
     // Add cards
     StatCard* addStatCard(const String& id, const String& title, const String& value = "", const String& unit = "") {
         StatCard* card = new StatCard(id, title, value, unit);
         _cards[id] = card;
         return card;
     }
     
     StatusCard* addStatusCard(const String& id, const String& title, StatusIcon icon = StatusIcon::INFO) {
         StatusCard* card = new StatusCard(id, title, icon);
         _cards[id] = card;
         return card;
     }
     
     ChartCard* addChartCard(const String& id, const String& title, ChartType type = ChartType::LINE, int maxPoints = 20) {
         ChartCard* card = new ChartCard(id, title, type, maxPoints);
         _cards[id] = card;
         return card;
     }
     
     ButtonCardImpl* addButtonCard(const String& id, const String& title, const String& label, ButtonCallback cb) {
         ButtonCardImpl* card = new ButtonCardImpl(id, title, label, cb);
         _cards[id] = card;
         return card;
     }
     
     LinkCard* addLinkCard(const String& id, const String& title, const String& label, const String& url) {
         LinkCard* card = new LinkCard(id, title, label, url);
         _cards[id] = card;
         return card;
     }
     
     TimezoneCard* addTimezoneCard(const String& id, const String& title, const String& label = "Get Browser Timezone") {
         TimezoneCard* card = new TimezoneCard(id, title, label);
         _cards[id] = card;
         return card;
     }
     
     DateCard* addDateCard(const String& id, const String& title, bool includeTime = false) {
         DateCard* card = new DateCard(id, title, includeTime);
         _cards[id] = card;
         return card;
     }
     
     ActionButton* addActionButton(const String& id, const String& title, const String& label,
                                   const String& confirmTitle, const String& confirmMsg, ButtonCallback cb) {
         ActionButton* card = new ActionButton(id, title, label, confirmTitle, confirmMsg, cb);
         _cards[id] = card;
         return card;
     }
     
     InputCard* addInputCard(const String& id, const String& title, const String& placeholder = "") {
         InputCard* card = new InputCard(id, title, placeholder);
         _cards[id] = card;
         return card;
     }
     
     ColorPickerCard* addColorPickerCard(const String& id, const String& title, const String& defaultColor = "#00D4AA") {
         ColorPickerCard* card = new ColorPickerCard(id, title, defaultColor);
         _cards[id] = card;
         return card;
     }
     
     DropdownCardImpl* addDropdownCard(const String& id, const String& title, const String& placeholder = "Select...") {
         DropdownCardImpl* card = new DropdownCardImpl(id, title, placeholder);
         _cards[id] = card;
         return card;
     }
     
     ToggleCard* addToggleCard(const String& id, const String& title, const String& label = "", bool defaultValue = false) {
         ToggleCard* card = new ToggleCard(id, title, label, defaultValue);
         _cards[id] = card;
         return card;
     }
     
     SliderCard* addSliderCard(const String& id, const String& title, int min = 0, int max = 100, int step = 1, const String& unit = "") {
         SliderCard* card = new SliderCard(id, title, min, max, step, unit);
         _cards[id] = card;
         return card;
     }
     
     GaugeCard* addGaugeCard(const String& id, const String& title, float min = 0, float max = 100, const String& unit = "%") {
         GaugeCard* card = new GaugeCard(id, title, min, max, unit);
         _cards[id] = card;
         return card;
     }
     
     OTACard* addOTACard(const String& id = "ota", const String& title = "Firmware Update (OTA)", int maxSize = 4) {
         OTACard* card = new OTACard(id, title, maxSize);
         _cards[id] = card;
         return card;
     }
     
     ConsoleCard* addConsoleCard(const String& id, const String& title = "Console Log", int maxEntries = 100) {
         ConsoleCard* card = new ConsoleCard(id, title, maxEntries);
         _cards[id] = card;
         return card;
     }
     
     // Get card by ID
     DashboardCard* getCard(const String& id) {
         if (_cards.find(id) != _cards.end()) {
             return _cards[id];
         }
         return nullptr;
     }
     
     // Remove card
     void removeCard(const String& id) {
         if (_cards.find(id) != _cards.end()) {
             delete _cards[id];
             _cards.erase(id);
             
             // Notify clients
             StaticJsonDocument<256> doc;
             doc["type"] = "remove";
             doc["cardId"] = id;
             
             String output;
             serializeJson(doc, output);
             if (_ws) _ws->textAll(output);
         }
     }
     
     // Update helpers
     void updateStatCard(const String& id, const String& value) {
         StatCard* card = static_cast<StatCard*>(getCard(id));
         if (card && card->type == CardType::STAT) {
             card->setValue(value);
             
             StaticJsonDocument<256> doc;
             JsonObject data = doc.to<JsonObject>();
             data["value"] = value;
             broadcastUpdate(id, data);
         }
     }
     
     void updateStatusCard(const String& id, StatusIcon icon, CardVariant variant, const String& label, const String& message) {
         StatusCard* card = static_cast<StatusCard*>(getCard(id));
         if (card && card->type == CardType::STATUS) {
             card->setStatus(icon, variant, label, message);
             
             StaticJsonDocument<512> doc;
             JsonObject data = doc.to<JsonObject>();
             data["icon"] = card->getIconString(icon);
             data["variant"] = card->getVariantString();
             data["label"] = label;
             data["message"] = message;
             broadcastUpdate(id, data);
         }
     }
     
     void updateChartCard(const String& id, float value) {
         ChartCard* card = static_cast<ChartCard*>(getCard(id));
         if (card && card->type == CardType::CHART) {
             card->addDataPoint(value);
             
             DynamicJsonDocument doc(2048);
             JsonObject data = doc.to<JsonObject>();
             JsonArray dataArr = data["data"].to<JsonArray>();
             for (float v : card->data) {
                 dataArr.add(v);
             }
             broadcastUpdate(id, data);
         }
     }
     
     void updateGaugeCard(const String& id, float value) {
         GaugeCard* card = static_cast<GaugeCard*>(getCard(id));
         if (card && card->type == CardType::GAUGE) {
             card->setValue(value);
             
             StaticJsonDocument<256> doc;
             JsonObject data = doc.to<JsonObject>();
             data["value"] = value;
             broadcastUpdate(id, data);
         }
     }
     
     void updateToggleCard(const String& id, bool value) {
         ToggleCard* card = static_cast<ToggleCard*>(getCard(id));
         if (card && card->type == CardType::TOGGLE) {
             card->setValue(value);
             
             StaticJsonDocument<256> doc;
             JsonObject data = doc.to<JsonObject>();
             data["value"] = value;
             broadcastUpdate(id, data);
         }
     }
     
     void updateSliderCard(const String& id, int value) {
         SliderCard* card = static_cast<SliderCard*>(getCard(id));
         if (card && card->type == CardType::SLIDER) {
             card->setValue(value);
             
             StaticJsonDocument<256> doc;
             JsonObject data = doc.to<JsonObject>();
             data["value"] = value;
             broadcastUpdate(id, data);
         }
     }
     
     void updateColorCard(const String& id, const String& color) {
         ColorPickerCard* card = static_cast<ColorPickerCard*>(getCard(id));
         if (card && card->type == CardType::COLOR) {
             card->setValue(color);
             
             StaticJsonDocument<256> doc;
             JsonObject data = doc.to<JsonObject>();
             data["value"] = color;
             broadcastUpdate(id, data);
         }
     }
     
     void updateDropdownCard(const String& id, const String& value) {
         DropdownCardImpl* card = static_cast<DropdownCardImpl*>(getCard(id));
         if (card && card->type == CardType::DROPDOWN) {
             card->setValue(value);
             
             StaticJsonDocument<256> doc;
             JsonObject data = doc.to<JsonObject>();
             data["value"] = value;
             broadcastUpdate(id, data);
         }
     }
     
     void updateDateCard(const String& id, const String& value) {
         DateCard* card = static_cast<DateCard*>(getCard(id));
         if (card && card->type == CardType::DATE) {
             card->setValue(value);
             
             StaticJsonDocument<256> doc;
             JsonObject data = doc.to<JsonObject>();
             data["value"] = value;
             broadcastUpdate(id, data);
         }
     }
     
     void updateLinkCard(const String& id, const String& url) {
         LinkCard* card = static_cast<LinkCard*>(getCard(id));
         if (card && card->type == CardType::LINK) {
             card->setUrl(url);
             
             StaticJsonDocument<256> doc;
             JsonObject data = doc.to<JsonObject>();
             data["url"] = url;
             broadcastUpdate(id, data);
         }
     }
     
    // ========================================
    // Console Log Functions (Serial.println-like API)
    // ========================================
    
    /**
     * Log a debug message to the console card
     */
    void logDebug(const String& consoleId, const String& message) {
        logToConsole(consoleId, LogLevel::DEBUG, message);
    }
    
    /**
     * Log an info message to the console card
     */
    void logInfo(const String& consoleId, const String& message) {
        logToConsole(consoleId, LogLevel::INFO, message);
    }
    
    /**
     * Log a warning message to the console card
     */
    void logWarning(const String& consoleId, const String& message) {
        logToConsole(consoleId, LogLevel::WARNING, message);
    }
    
    /**
     * Log an error message to the console card
     */
    void logError(const String& consoleId, const String& message) {
        logToConsole(consoleId, LogLevel::ERROR, message);
    }
    
    /**
     * Generic log function with level
     */
    void log(const String& consoleId, LogLevel level, const String& message) {
        logToConsole(consoleId, level, message);
    }
    
    /**
     * Clear all logs from a console card
     */
    void clearConsole(const String& consoleId) {
        ConsoleCard* card = static_cast<ConsoleCard*>(getCard(consoleId));
        if (card && card->type == CardType::CONSOLE) {
            card->clear();
            
            DynamicJsonDocument doc(512);
            JsonObject data = doc.to<JsonObject>();
            JsonArray logsArr = data["logs"].to<JsonArray>();
            broadcastUpdate(consoleId, data);
        }
    }
    
    // ========================================
    // Global Log Functions (without card ID)
    // Logs to Console tab if enableConsole = true
    // ========================================
    
    /**
     * Log a debug message to the Console tab (no card required)
     */
    void logDebug(const String& message) {
        broadcastLog(LogLevel::DEBUG, message);
    }
    
    /**
     * Log an info message to the Console tab (no card required)
     */
    void logInfo(const String& message) {
        broadcastLog(LogLevel::INFO, message);
    }
    
    /**
     * Log a warning message to the Console tab (no card required)
     */
    void logWarning(const String& message) {
        broadcastLog(LogLevel::WARNING, message);
    }
    
    /**
     * Log an error message to the Console tab (no card required)
     */
    void logError(const String& message) {
        broadcastLog(LogLevel::ERROR, message);
    }
    
    /**
     * Generic log function with level (no card required)
     */
    void log(LogLevel level, const String& message) {
        broadcastLog(level, message);
    }
     
private:
    void logToConsole(const String& consoleId, LogLevel level, const String& message) {
        ConsoleCard* card = static_cast<ConsoleCard*>(getCard(consoleId));
        if (card && card->type == CardType::CONSOLE) {
            card->addLog(level, message);
            
            // Broadcast the new log entry
            DynamicJsonDocument doc(4096);
            JsonObject data = doc.to<JsonObject>();
            JsonArray logsArr = data["logs"].to<JsonArray>();
            for (const LogEntry& entry : card->logs) {
                JsonObject logObj = logsArr.add<JsonObject>();
                logObj["timestamp"] = entry.timestamp;
                logObj["level"] = card->getLogLevelString(entry.level);
                logObj["message"] = entry.message;
            }
            broadcastUpdate(consoleId, data);
        }
    }
    
    // Broadcast log directly to Console tab (without a card)
    void broadcastLog(LogLevel level, const String& message) {
        if (!_ws || !_enableConsole) return;
        
        // Get timestamp
        unsigned long ms = millis();
        unsigned long secs = ms / 1000;
        unsigned long mins = secs / 60;
        unsigned long hours = mins / 60;
        
        char timestamp[16];
        snprintf(timestamp, sizeof(timestamp), "%02lu:%02lu:%02lu.%03lu", 
                 hours % 24, mins % 60, secs % 60, ms % 1000);
        
        // Convert level to string
        String levelStr;
        switch (level) {
            case LogLevel::DEBUG: levelStr = "debug"; break;
            case LogLevel::INFO: levelStr = "info"; break;
            case LogLevel::WARNING: levelStr = "warning"; break;
            case LogLevel::ERROR: levelStr = "error"; break;
            default: levelStr = "info"; break;
        }
        
        StaticJsonDocument<512> doc;
        doc["type"] = "log";
        doc["timestamp"] = timestamp;
        doc["level"] = levelStr;
        doc["message"] = message;
        
        String output;
        serializeJson(doc, output);
        _ws->textAll(output);
    }
};

#endif // ESP_DASHBOARD_PLUS_H
 