#!/usr/bin/env python3
"""
PlatformIO Pre-Build Script for ESP Dashboard

This script is automatically executed by PlatformIO before each build.
It converts the dashboard.html file into a gzip-compressed C++ header
file that can be stored in PROGMEM.

Library Structure:
    ESP-DashboardPlus/
    ├── src/
    │   ├── ESPDashboardPlus.h
    │   └── dashboard_html.h      <- Generated output
    ├── extras/
    │   └── dashboard.html        <- Input HTML
    └── scripts/
        └── html_to_header_pio.py <- This script

Usage (automatic via platformio.ini):
    extra_scripts = pre:scripts/html_to_header_pio.py

Manual usage:
    python scripts/html_to_header_pio.py
"""

import os
import sys
import gzip
import hashlib
from datetime import datetime
from pathlib import Path

def get_lib_root():
    """Get the library root directory (parent of scripts/)."""
    script_dir = Path(__file__).parent.absolute()
    return script_dir.parent

def calculate_hash(content):
    """Calculate MD5 hash of content."""
    return hashlib.md5(content).hexdigest()

def should_regenerate(html_path, hash_path, header_path):
    """Check if we need to regenerate the header file."""
    # Always regenerate if header doesn't exist
    if not os.path.exists(header_path):
        return True
    
    # Check if HTML file exists
    if not os.path.exists(html_path):
        print(f"[ESP-DashboardPlus] Warning: {html_path} not found")
        return False
    
    # Read current HTML content
    with open(html_path, 'rb') as f:
        current_content = f.read()
    current_hash = calculate_hash(current_content)
    
    # Check stored hash
    if os.path.exists(hash_path):
        with open(hash_path, 'r') as f:
            stored_hash = f.read().strip()
        if current_hash == stored_hash:
            return False
    
    return True

def compress_html(html_content):
    """Compress HTML content using gzip with maximum compression."""
    return gzip.compress(html_content, compresslevel=9)

def bytes_to_c_array(data, bytes_per_line=16):
    """Convert bytes to C-style array format."""
    lines = []
    for i in range(0, len(data), bytes_per_line):
        chunk = data[i:i + bytes_per_line]
        hex_values = ', '.join(f'0x{b:02X}' for b in chunk)
        lines.append(f'    {hex_values}')
    return ',\n'.join(lines)

def generate_header(html_path, header_path, hash_path):
    """Generate the C++ header file from HTML."""
    print(f"[ESP-DashboardPlus] Converting extras/dashboard.html to src/dashboard_html.h...")
    
    # Read HTML file
    with open(html_path, 'rb') as f:
        html_content = f.read()
    
    original_size = len(html_content)
    
    # Compress
    compressed = compress_html(html_content)
    compressed_size = len(compressed)
    
    compression_ratio = (1 - compressed_size / original_size) * 100
    
    # Generate C array
    c_array = bytes_to_c_array(compressed)
    
    # Content hash for versioning
    content_hash = calculate_hash(html_content)[:8]
    
    # Generate header content
    header_content = f'''/**
 * ESP Dashboard - Compressed HTML Header
 * 
 * Auto-generated by html_to_header_pio.py (PlatformIO pre-build script)
 * DO NOT EDIT MANUALLY - changes will be overwritten!
 * 
 * Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
 * Content hash: {content_hash}
 * 
 * Source: extras/dashboard.html
 * Original size: {original_size:,} bytes
 * Compressed size: {compressed_size:,} bytes
 * Compression ratio: {compression_ratio:.1f}%
 * 
 * ESP Dashboard Library
 * https://github.com/aaronbeckmann/ESP-DashboardPlus
 */

#ifndef DASHBOARD_HTML_H
#define DASHBOARD_HTML_H

#include <Arduino.h>
#include <pgmspace.h>

// Size constants
#define DASHBOARD_HTML_SIZE {compressed_size}
#define DASHBOARD_HTML_ORIGINAL_SIZE {original_size}
#define DASHBOARD_HTML_HASH "{content_hash}"

// Compressed HTML data in PROGMEM
const uint8_t DASHBOARD_HTML_DATA[{compressed_size}] PROGMEM = {{
{c_array}
}};

#endif // DASHBOARD_HTML_H
'''

    # Ensure output directory exists
    os.makedirs(os.path.dirname(header_path), exist_ok=True)
    
    # Write output file
    with open(header_path, 'w', encoding='utf-8') as f:
        f.write(header_content)
    
    # Save hash
    current_hash = calculate_hash(html_content)
    with open(hash_path, 'w') as f:
        f.write(current_hash)
    
    print(f"[ESP-DashboardPlus] ✓ Generated src/dashboard_html.h")
    print(f"[ESP-DashboardPlus]   Original:   {original_size:>8,} bytes")
    print(f"[ESP-DashboardPlus]   Compressed: {compressed_size:>8,} bytes ({compression_ratio:.1f}% reduction)")

def main():
    """Main entry point."""
    lib_root = get_lib_root()
    
    html_path = lib_root / 'extras' / 'dashboard.html'
    header_path = lib_root / 'src' / 'dashboard_html.h'
    hash_path = lib_root / 'src' / '.dashboard_hash'
    
    # Check if regeneration is needed
    if should_regenerate(html_path, hash_path, header_path):
        if html_path.exists():
            generate_header(html_path, header_path, hash_path)
        else:
            print(f"[ESP-DashboardPlus] Warning: extras/dashboard.html not found, skipping header generation")
    else:
        print(f"[ESP-DashboardPlus] src/dashboard_html.h is up-to-date")

# PlatformIO hook
Import = None
try:
    from SCons.Script import Import as SConsImport
    Import = SConsImport
except ImportError:
    pass

if Import:
    # Running as PlatformIO script
    try:
        Import("env")
        # Run the conversion before build
        main()
    except Exception as e:
        print(f"[ESP-DashboardPlus] Note: Running standalone ({e})")
        main()
else:
    # Running standalone
    if __name__ == '__main__':
        main()
