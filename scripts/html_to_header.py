#!/usr/bin/env python3
"""
ESP Dashboard - HTML to C++ Header Converter

Standalone script to convert dashboard.html to a gzip-compressed
C++ header file that can be stored in PROGMEM on ESP32/ESP8266 devices.

Usage:
    python html_to_header.py [input_file] [output_file]
    
    Default paths (relative to library root):
        Input:  extras/dashboard.html
        Output: src/dashboard_html.h

The generated header file includes:
- Gzip-compressed HTML data stored in PROGMEM
- Size constants for the compressed and uncompressed data
- Helper functions for serving the content
"""

import sys
import gzip
import os
import hashlib
from datetime import datetime
from pathlib import Path

def get_lib_root():
    """Get the library root directory (parent of scripts/)."""
    script_dir = Path(__file__).parent.absolute()
    return script_dir.parent

def compress_html(html_content: bytes) -> bytes:
    """Compress HTML content using gzip with maximum compression."""
    return gzip.compress(html_content, compresslevel=9)

def bytes_to_c_array(data: bytes, bytes_per_line: int = 16) -> str:
    """Convert bytes to C-style array format."""
    lines = []
    for i in range(0, len(data), bytes_per_line):
        chunk = data[i:i + bytes_per_line]
        hex_values = ', '.join(f'0x{b:02X}' for b in chunk)
        lines.append(f'    {hex_values}')
    return ',\n'.join(lines)

def generate_header(html_path: str, output_path: str) -> None:
    """Generate the C++ header file from HTML."""
    
    # Read HTML file
    with open(html_path, 'rb') as f:
        html_content = f.read()
    
    original_size = len(html_content)
    
    # Compress
    compressed = compress_html(html_content)
    compressed_size = len(compressed)
    
    compression_ratio = (1 - compressed_size / original_size) * 100
    
    # Content hash for versioning
    content_hash = hashlib.md5(html_content).hexdigest()[:8]
    
    # Generate C array
    c_array = bytes_to_c_array(compressed)
    
    # Generate header content
    header_content = f'''/**
 * ESP Dashboard - Compressed HTML Header
 * 
 * Auto-generated by html_to_header.py
 * DO NOT EDIT MANUALLY - changes will be overwritten!
 * 
 * Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
 * Content hash: {content_hash}
 * 
 * Source: {os.path.basename(html_path)}
 * Original size: {original_size:,} bytes
 * Compressed size: {compressed_size:,} bytes
 * Compression ratio: {compression_ratio:.1f}%
 * 
 * ESP Dashboard Library
 * https://github.com/aaronbeckmann/ESP-DashboardPlus
 */

#ifndef DASHBOARD_HTML_H
#define DASHBOARD_HTML_H

#include <Arduino.h>
#include <pgmspace.h>

// Size constants
#define DASHBOARD_HTML_SIZE {compressed_size}
#define DASHBOARD_HTML_ORIGINAL_SIZE {original_size}
#define DASHBOARD_HTML_HASH "{content_hash}"

// Compressed HTML data in PROGMEM
const uint8_t DASHBOARD_HTML_DATA[{compressed_size}] PROGMEM = {{
{c_array}
}};

/**
 * Helper function to serve the dashboard HTML
 * Can be used directly with AsyncWebServer
 * 
 * Example:
 *   server.on("/", HTTP_GET, serveDashboardHTML);
 */
#ifdef ESP_ASYNC_WEBSERVER_H
inline void serveDashboardHTML(AsyncWebServerRequest *request) {{
    AsyncWebServerResponse *response = request->beginResponse_P(
        200, "text/html", DASHBOARD_HTML_DATA, DASHBOARD_HTML_SIZE);
    response->addHeader("Content-Encoding", "gzip");
    response->addHeader("Cache-Control", "max-age=86400");
    request->send(response);
}}
#endif

#endif // DASHBOARD_HTML_H
'''

    # Ensure output directory exists
    os.makedirs(os.path.dirname(output_path) or '.', exist_ok=True)
    
    # Write output file
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(header_content)
    
    print(f"âœ“ Generated: {output_path}")
    print(f"  Original size:   {original_size:>8,} bytes")
    print(f"  Compressed size: {compressed_size:>8,} bytes")
    print(f"  Compression:     {compression_ratio:>7.1f}%")
    print(f"  Savings:         {original_size - compressed_size:>8,} bytes")

def main():
    lib_root = get_lib_root()
    
    # Default file paths
    default_input = lib_root / 'extras' / 'dashboard.html'
    default_output = lib_root / 'src' / 'dashboard_html.h'
    
    # Parse command line arguments
    if len(sys.argv) >= 3:
        input_file = sys.argv[1]
        output_file = sys.argv[2]
    elif len(sys.argv) == 2:
        input_file = sys.argv[1]
        output_file = str(default_output)
    else:
        input_file = str(default_input)
        output_file = str(default_output)
    
    # Check input file exists
    if not os.path.exists(input_file):
        print(f"Error: Input file '{input_file}' not found.")
        print(f"\nUsage: python {sys.argv[0]} [input_file] [output_file]")
        print(f"       Default: extras/dashboard.html -> src/dashboard_html.h")
        sys.exit(1)
    
    print(f"ESP Dashboard - HTML to Header Converter")
    print(f"=" * 50)
    print(f"Converting {input_file}")
    print(f"       to {output_file}")
    print()
    
    generate_header(input_file, output_file)
    print("\nDone! Include the header file in your ESP32 project.")

if __name__ == '__main__':
    main()
